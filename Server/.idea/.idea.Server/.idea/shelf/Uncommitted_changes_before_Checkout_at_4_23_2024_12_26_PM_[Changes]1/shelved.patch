Index: MessageAppServer/Services/User/IUserServices.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Server.Model;\r\nusing Server.Model.Responses.User;\r\n\r\nnamespace Server.Services.User;\r\n\r\npublic interface IUserServices\r\n{\r\n    string SaveImageLocally(string userNameFileName, string base64Image);\r\n    string GetContentType(string filePath);\r\n    Task<DeleteUserResponse> DeleteAsync(ApplicationUser user);\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/MessageAppServer/Services/User/IUserServices.cs b/MessageAppServer/Services/User/IUserServices.cs
--- a/MessageAppServer/Services/User/IUserServices.cs	
+++ b/MessageAppServer/Services/User/IUserServices.cs	
@@ -1,11 +1,6 @@
-using Server.Model;
-using Server.Model.Responses.User;
-
 namespace Server.Services.User;
 
 public interface IUserServices
 {
     string SaveImageLocally(string userNameFileName, string base64Image);
-    string GetContentType(string filePath);
-    Task<DeleteUserResponse> DeleteAsync(ApplicationUser user);
 }
\ No newline at end of file
Index: MessageAppServer/Services/Authentication/AuthService.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Microsoft.AspNetCore.Identity;\r\nusing Server.Model;\r\nusing Server.Model.Responses.Auth;\r\nusing Server.Model.Responses.User;\r\nusing Server.Services.Cookie;\r\n\r\nnamespace Server.Services.Authentication;\r\n\r\npublic class AuthService(\r\n    UserManager<ApplicationUser> userManager,\r\n    ITokenService tokenService,\r\n    ICookieService cookieService) : IAuthService\r\n{\r\n    public async Task<AuthResult> RegisterAsync(string email, string username, string password, string role, string phoneNumber, string image)\r\n    {\r\n        var user = new ApplicationUser(image)\r\n        {\r\n            UserName = username,\r\n            Email = email,\r\n            PhoneNumber = phoneNumber,\r\n            PhoneNumberConfirmed = false,\r\n            EmailConfirmed = true,\r\n            TwoFactorEnabled = true,\r\n            LockoutEnabled = false\r\n        };\r\n        \r\n        var result = await userManager.CreateAsync(user, password);\r\n\r\n        if (!result.Succeeded)\r\n        {\r\n            return FailedRegistration(result);\r\n        }\r\n\r\n        await userManager.AddToRoleAsync(user, role);\r\n        return new AuthResult(true, \"\", \"\");\r\n    }\r\n\r\n    private static AuthResult FailedRegistration(IdentityResult result)\r\n    {\r\n        var authenticationResult = new AuthResult(false, \"\", \"\");\r\n\r\n        foreach (var identityError in result.Errors)\r\n        {\r\n            authenticationResult.ErrorMessages.Add(identityError.Code, identityError.Description);\r\n        }\r\n\r\n        return authenticationResult;\r\n    }\r\n\r\n    public async Task<AuthResult> LoginAsync(string username, bool rememberMe)\r\n    {\r\n        var managedUser = await userManager.FindByNameAsync(username);\r\n        \r\n        if (managedUser == null)\r\n        {\r\n            return new AuthResult(false, \"\", \"\");\r\n        }\r\n        \r\n        var roles = await userManager.GetRolesAsync(managedUser);\r\n        var accessToken = tokenService.CreateJwtToken(managedUser, roles[0], rememberMe);\r\n        \r\n        if (rememberMe)\r\n        {\r\n            cookieService.SetRefreshToken(managedUser);\r\n            await userManager.UpdateAsync(managedUser);\r\n        }\r\n\r\n        cookieService.SetRememberMeCookie(rememberMe);\r\n        cookieService.SetUserId(managedUser.Id, rememberMe);\r\n        cookieService.SetAnimateAndAnonymous(rememberMe);\r\n        await cookieService.SetJwtToken(accessToken, rememberMe);\r\n        \r\n        return new AuthResult(true, managedUser.Id, \"\");\r\n    }\r\n\r\n    public async Task<AuthResult> LoginWithGoogle(string emailAddress)\r\n    {\r\n        var managedUser = await userManager.FindByEmailAsync(emailAddress);\r\n        \r\n        if (managedUser == null)\r\n        {\r\n            return new AuthResult(false, \"\", \"\");\r\n        }\r\n        \r\n        var roles = await userManager.GetRolesAsync(managedUser);\r\n        var accessToken = tokenService.CreateJwtToken(managedUser, roles[0], true);\r\n        \r\n        cookieService.SetRefreshToken(managedUser);\r\n        await userManager.UpdateAsync(managedUser);\r\n\r\n        cookieService.SetRememberMeCookie(true);\r\n        cookieService.SetUserId(managedUser.Id, true);\r\n        cookieService.SetAnimateAndAnonymous(true);\r\n        await cookieService.SetJwtToken(accessToken, true);\r\n        \r\n        return new AuthResult(true, managedUser.Id, \"\");\r\n    }\r\n\r\n    public Task<string?> GetEmailFromUserName(string username)\r\n    {\r\n        return Task.FromResult(userManager.Users.FirstOrDefault(user => user.UserName == username)?.Email);\r\n    }\r\n\r\n    public async Task<AuthResult> ExamineLoginCredentials(string username, string password)\r\n    {\r\n        var managedUser = await userManager.FindByNameAsync(username);\r\n\r\n        if (managedUser == null)\r\n        {\r\n            return InvalidCredentials(\"Invalid username or password\");\r\n        }\r\n        \r\n        var lockoutEndDate = await userManager.GetLockoutEndDateAsync(managedUser);\r\n\r\n        if (lockoutEndDate.HasValue && lockoutEndDate.Value > DateTimeOffset.Now)\r\n        {\r\n            return InvalidCredentials($\"Account is locked. Try again after {lockoutEndDate.Value - DateTimeOffset.Now}\");\r\n        }\r\n\r\n        await userManager.SetLockoutEndDateAsync(managedUser, null);\r\n        \r\n        var userLockout = userManager.GetAccessFailedCountAsync(managedUser).Result >= 4;\r\n        \r\n        if (userLockout)\r\n        {\r\n            await userManager.SetLockoutEndDateAsync(managedUser, DateTimeOffset.Now.AddDays(1));\r\n            await userManager.ResetAccessFailedCountAsync(managedUser);\r\n            return InvalidCredentials($\"Account is locked. Try again after 1 day\");\r\n        }\r\n\r\n        var isPasswordValid = await userManager.CheckPasswordAsync(managedUser, password);\r\n\r\n        if (!isPasswordValid)\r\n        {\r\n            await userManager.AccessFailedAsync(managedUser);\r\n            return InvalidCredentials(userManager.GetAccessFailedCountAsync(managedUser).Result.ToString());\r\n        }\r\n        \r\n        await userManager.ResetAccessFailedCountAsync(managedUser);\r\n\r\n        return new AuthResult(true, managedUser.Id, managedUser.Email!);\r\n    }\r\n\r\n    public async Task<AuthResult> LogOut(string userId)\r\n    {\r\n        var user = userManager.Users.FirstOrDefault(user => user.Id == userId);\r\n        user!.RefreshToken = string.Empty;\r\n        user.RefreshTokenExpires = null;\r\n        user.RefreshTokenCreated = null;\r\n        await userManager.UpdateAsync(user);\r\n        cookieService.DeleteCookies();\r\n        return new AuthResult(true, \"-\", \"-\");\r\n    }\r\n\r\n    private FailedAuthResult InvalidCredentials(string message)\r\n    {\r\n        var result = new FailedAuthResult(false, \"-\", \"-\", message);\r\n        result.ErrorMessages.Add(\"Bad credentials\", \"Invalid email\");\r\n        return result;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/MessageAppServer/Services/Authentication/AuthService.cs b/MessageAppServer/Services/Authentication/AuthService.cs
--- a/MessageAppServer/Services/Authentication/AuthService.cs	
+++ b/MessageAppServer/Services/Authentication/AuthService.cs	
@@ -158,4 +158,25 @@
         result.ErrorMessages.Add("Bad credentials", "Invalid email");
         return result;
     }
+    
+    public async Task<DeleteUserResponse> DeleteAsync(string username, string password)
+    {
+        var managedUser = await userManager.FindByNameAsync(username);
+
+        if (managedUser == null)
+        {
+            return new DeleteUserResponse($"{username}", "Doesn't exist in the database", false);
+        }
+
+        var isPasswordValid = await userManager.CheckPasswordAsync(managedUser, password);
+
+        if (!isPasswordValid)
+        {
+            return new DeleteUserResponse($"{username}", "For this user, the given credentials doesn't match.", false);
+        }
+
+        await userManager.DeleteAsync(managedUser);
+
+        return new DeleteUserResponse($"{username}", "Delete successful.", true);
+    }
 }
\ No newline at end of file
Index: MessageAppServer/Services/Authentication/IAuthService.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Server.Model.Responses.Auth;\r\nusing Server.Model.Responses.User;\r\n\r\nnamespace Server.Services.Authentication;\r\n\r\npublic interface IAuthService\r\n{\r\n    Task<AuthResult> RegisterAsync(string email, string username, string password, string role, string phoneNumber, string image);\r\n    Task<AuthResult> LoginAsync(string username, bool rememberMe);\r\n    Task<AuthResult> LoginWithGoogle(string emailAddress);\r\n    Task<string?> GetEmailFromUserName(string username);\r\n    Task<AuthResult> ExamineLoginCredentials(string username, string password);\r\n    Task<AuthResult> LogOut(string userId);\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/MessageAppServer/Services/Authentication/IAuthService.cs b/MessageAppServer/Services/Authentication/IAuthService.cs
--- a/MessageAppServer/Services/Authentication/IAuthService.cs	
+++ b/MessageAppServer/Services/Authentication/IAuthService.cs	
@@ -11,4 +11,5 @@
     Task<string?> GetEmailFromUserName(string username);
     Task<AuthResult> ExamineLoginCredentials(string username, string password);
     Task<AuthResult> LogOut(string userId);
+    Task<DeleteUserResponse> DeleteAsync(string username, string password);
 }
\ No newline at end of file
